{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Getting Started VisualKey is a Graphics Sketchbook, in the sense that it enables you to work directly with Shaders, Meshes, Window, Input, Texture, Audio, Text and Light systems, each at the level you need. For example, you can use a pre-created Rectangle Mesh, or you can create your own Mesh with the necessary Vertices and optional Indices. Installation To get started you must first install VisualKey, at the moment it works with Windows 64 bits and Linux 64 bits. To download the installer go to the releases tab in the GitHub repo. In the Windows installer be sure to enable Add to Path either for all Users or just for yourself. The installed version is self-contained, since it contains the Mono utilities and libraries necessary to run any VisualKey project. Basics To begin using VisualKey you can make use of the command line interface to either run an existing project or to create one: visualkey init . visualkey run . The created project contains a csproject which can be used to open almost any editor that supports C#. It also contains a .vscode folder with tasks to easily run your project using Visual Studio Code, and a .run folder to easily run your project in the JetBrains Rider IDE. Visual Studio Code In VSCode open a folder, in which your project will be created and stored. Presse ctrl + ` to open the integrated terminal, or run the command Terminal: Create New Integrated Terminal in the show commands panel (ctrl + shift + p). Type: visualkey init . Hint If there's an error message which states that visualkey is not an existing command, please restart VSCode. If the problem persists please reinstall VisualKey and be sure to enable Add to Path . With the default project created, you will have an App.cs which is the entry point for VisualKey. You can create any other C# source files and they will be linked together at run time. Autocompletion To enable autocompletion you need the C# extension. A pop-up should show up when you load the project recommending you to install the C# extension, but if not, open the extensions menu and seach for ms-dotnettools.csharp . The con of using this method of autocompletion is that it relies on an external installation of dotnet. Follow https://dotnet.microsoft.com/download download and install the SKD not the Runtime. Running To run your project you don't need any external installation of neither dotnet nor mono. You can call visualkey and run the project from the pre-generated tasks or via the command line. Task You can run the pre-generated build task by pressing: ctrl+shift+b in the default keybindings. CLI Run the project by calling the visualkey CLI: cd project-dir visualkey run . # OR visualkey run project-dir/","title":"Getting Started"},{"location":"#getting-started","text":"VisualKey is a Graphics Sketchbook, in the sense that it enables you to work directly with Shaders, Meshes, Window, Input, Texture, Audio, Text and Light systems, each at the level you need. For example, you can use a pre-created Rectangle Mesh, or you can create your own Mesh with the necessary Vertices and optional Indices.","title":"Getting Started"},{"location":"#installation","text":"To get started you must first install VisualKey, at the moment it works with Windows 64 bits and Linux 64 bits. To download the installer go to the releases tab in the GitHub repo. In the Windows installer be sure to enable Add to Path either for all Users or just for yourself. The installed version is self-contained, since it contains the Mono utilities and libraries necessary to run any VisualKey project.","title":"Installation"},{"location":"#basics","text":"To begin using VisualKey you can make use of the command line interface to either run an existing project or to create one: visualkey init . visualkey run . The created project contains a csproject which can be used to open almost any editor that supports C#. It also contains a .vscode folder with tasks to easily run your project using Visual Studio Code, and a .run folder to easily run your project in the JetBrains Rider IDE.","title":"Basics"},{"location":"#visual-studio-code","text":"In VSCode open a folder, in which your project will be created and stored. Presse ctrl + ` to open the integrated terminal, or run the command Terminal: Create New Integrated Terminal in the show commands panel (ctrl + shift + p). Type: visualkey init . Hint If there's an error message which states that visualkey is not an existing command, please restart VSCode. If the problem persists please reinstall VisualKey and be sure to enable Add to Path . With the default project created, you will have an App.cs which is the entry point for VisualKey. You can create any other C# source files and they will be linked together at run time.","title":"Visual Studio Code"},{"location":"#autocompletion","text":"To enable autocompletion you need the C# extension. A pop-up should show up when you load the project recommending you to install the C# extension, but if not, open the extensions menu and seach for ms-dotnettools.csharp . The con of using this method of autocompletion is that it relies on an external installation of dotnet. Follow https://dotnet.microsoft.com/download download and install the SKD not the Runtime.","title":"Autocompletion"},{"location":"#running","text":"To run your project you don't need any external installation of neither dotnet nor mono. You can call visualkey and run the project from the pre-generated tasks or via the command line.","title":"Running"},{"location":"#task","text":"You can run the pre-generated build task by pressing: ctrl+shift+b in the default keybindings.","title":"Task"},{"location":"#cli","text":"Run the project by calling the visualkey CLI: cd project-dir visualkey run . # OR visualkey run project-dir/","title":"CLI"},{"location":"audio/","text":"Audio It uses IRRKlang as a sound engine and audio library. It is free for non-commercial use but you must buy a license for commercial projects. You can visit the official license page for more information. A pull request with another sound engine would be highly appreciated. Please note that we would be looking for a cross platform solution and an audio library which at least supports WAV , OGG . Info Supports WAV, MP3, OGG, FLAC, MOD, XM, IT, S3M . Audio Class that manages a given audio file. Fields path Path of the audio file. (string) loop Toggle if the audio should play on a loop. (bool) Constructors Audio ( string path , bool loop = false ) Methods void Play () Play the given audio file, if on loop, will keep playing, on a loop... Example using VisualKey ; class App { Window window = new Window ( 1280 , 720 ); // Needed to keep the program open Audio audio = new Audio ( \"Kara Square - 8-Bit Side-Scrolling Action.wav\" , true ); void Start () { audio . Play (); } }","title":"Audio"},{"location":"audio/#audio","text":"It uses IRRKlang as a sound engine and audio library. It is free for non-commercial use but you must buy a license for commercial projects. You can visit the official license page for more information. A pull request with another sound engine would be highly appreciated. Please note that we would be looking for a cross platform solution and an audio library which at least supports WAV , OGG . Info Supports WAV, MP3, OGG, FLAC, MOD, XM, IT, S3M .","title":"Audio"},{"location":"audio/#audio_1","text":"Class that manages a given audio file.","title":"Audio"},{"location":"audio/#fields","text":"path Path of the audio file. (string) loop Toggle if the audio should play on a loop. (bool)","title":"Fields"},{"location":"audio/#constructors","text":"Audio ( string path , bool loop = false )","title":"Constructors"},{"location":"audio/#methods","text":"void Play () Play the given audio file, if on loop, will keep playing, on a loop...","title":"Methods"},{"location":"audio/#example","text":"using VisualKey ; class App { Window window = new Window ( 1280 , 720 ); // Needed to keep the program open Audio audio = new Audio ( \"Kara Square - 8-Bit Side-Scrolling Action.wav\" , true ); void Start () { audio . Play (); } }","title":"Example"},{"location":"camera/","text":"Camera This class is an implementation of a very simple Camera, it is fully written in C#, so it is a good example of what you can do with the tools given ( src ). By default, this class saves a reference to the Uber shader in order to set the View Uniform Matrix. To implement it into your project you must first call the Update function, which makes use of the WASD keys to move in XZ and QE to move in the Y axis. To properly render in a Perspective view enable those features in the Window object: camera . Update (); // Updates position and rotation, via the Input camera . Draw () // Sets the View uniform the given Shader window . Background ( 38 , 50 , 56 ); // Clear color buffer Window . SetPerspective ( MathV . Radians ( 90 )); // Sets Perspective view with a FOV of 90 window . HideCursor (); // Hides the cursor to lock it inside the window window . MakeCurrent (); // Recalculates and applies the Projection Matrix Functions Camera Creates a new Camera with the Uber Shader, position Vec3(0, 0, -3) and rotation Euler Vec2(-90, 0). void Update () Updates position and rotation via Input void Draw () Sets the View uniform in the given Shader void SetNone () Sets the View uniform to Mat4 Identity Mat4 GetView () Returns a Mat4 with the Calculated View Matrix","title":"Camera"},{"location":"camera/#camera","text":"This class is an implementation of a very simple Camera, it is fully written in C#, so it is a good example of what you can do with the tools given ( src ). By default, this class saves a reference to the Uber shader in order to set the View Uniform Matrix. To implement it into your project you must first call the Update function, which makes use of the WASD keys to move in XZ and QE to move in the Y axis. To properly render in a Perspective view enable those features in the Window object: camera . Update (); // Updates position and rotation, via the Input camera . Draw () // Sets the View uniform the given Shader window . Background ( 38 , 50 , 56 ); // Clear color buffer Window . SetPerspective ( MathV . Radians ( 90 )); // Sets Perspective view with a FOV of 90 window . HideCursor (); // Hides the cursor to lock it inside the window window . MakeCurrent (); // Recalculates and applies the Projection Matrix","title":"Camera"},{"location":"camera/#functions","text":"Camera Creates a new Camera with the Uber Shader, position Vec3(0, 0, -3) and rotation Euler Vec2(-90, 0). void Update () Updates position and rotation via Input void Draw () Sets the View uniform in the given Shader void SetNone () Sets the View uniform to Mat4 Identity Mat4 GetView () Returns a Mat4 with the Calculated View Matrix","title":"Functions"},{"location":"graphics/","text":"Graphics As a backend the project is using an OpenGL 3.2 renderer. It abstracts this renderer into a Mesh system, then it further simplifies it into 3D shapes. The user is able to access both the Mesh system and the Shapes system. To change the position of certain Meshes (Shapes) it uses a single state, which can be modified by using the Mesh.Translate function. This single state is shared between all the Meshes, so the responsibility of managing it lies on the user. A way to save the current position and rotation state is to create a Stash , you can create a new Stash by creating its object Stash stash = new Stash (); . This takes a snapshot of the current state which you can modify in any way you want. To recover this snapshot of a state, it is as simple as stash . Pop (); . This doesn't invalidate the state saved in the Stash, so you can further reuse it. Mesh The base object, which holds the information about the mesh, this being: vertices, indices and primitive type. Constructors Mesh ( float [] vertices , bool isLine = false ) Mesh ( float [] vertices , uint [] indices , bool isLine = false ) The isLine parameter changes the primitive type of the Mesh into GL_LINES from GL_TRIANGLES . Methods static void Translate(Vec3 position) Set state's position value. static void Rotate(Vec3 rotation) Set state's rotation value. static void RotateX(float rotation) Set state's rotation value. static void RotateY(float rotation) Set state's rotation value. static void RotateZ(float rotation) Set state's rotation value. static void PolygonMode(bool mode) Set true to fill polygons, and false not. Example As it is using an Uber shader at the moment, all the meshes, indistinctly of them being 2D or 3D, use 8 f32 to represent Vertex. The first 3 values are the position of the Vertex, followed by 2 values of Texture Coordinates, finished by 3 values of the Vertex's Normals. public class Line { public Mesh mesh { get ; private set ; } private void CreateLine ( float p0x , float p0y , float p1x , float p1y ) { float [] vertices = { p0x , p0y , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , p1x , p1y , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f }; mesh = new Mesh ( vertices , true ); } public Line ( float p0x , float p0y , float p1x , float p1y ) { CreateLine ( p0x , p0y , p1x , p1y ); } public Line ( Vec2 p0 , Vec2 p1 ) { CreateLine ( p0 . x , p0 . y , p1 . x , p1 . y ); } public void Draw () { mesh . Draw (); } } You can also, make Meshes with Indices for the Vertices: public class Rectangle { public Mesh mesh { get ; private set ; } public Rectangle ( float width , float height ) { float [] vertices = { ( width / 2.0f ), ( height / 2.0f ), 0.0f , 1.0f , 1.0f , 0.0f , 0.0f , 0.0f , ( width / 2.0f ), -( height / 2.0f ), 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , -( width / 2.0f ), -( height / 2.0f ), 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , -( width / 2.0f ), ( height / 2.0f ), 0.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f }; uint [] indices = { 0 , 2 , 1 , 2 , 0 , 3 }; mesh = new Mesh ( vertices , indices ); } public void Draw () { mesh . Draw (); } } Please take into consideration that the renderer enables Culling in a Counter Clock Wise mode.","title":"Graphics"},{"location":"graphics/#graphics","text":"As a backend the project is using an OpenGL 3.2 renderer. It abstracts this renderer into a Mesh system, then it further simplifies it into 3D shapes. The user is able to access both the Mesh system and the Shapes system. To change the position of certain Meshes (Shapes) it uses a single state, which can be modified by using the Mesh.Translate function. This single state is shared between all the Meshes, so the responsibility of managing it lies on the user. A way to save the current position and rotation state is to create a Stash , you can create a new Stash by creating its object Stash stash = new Stash (); . This takes a snapshot of the current state which you can modify in any way you want. To recover this snapshot of a state, it is as simple as stash . Pop (); . This doesn't invalidate the state saved in the Stash, so you can further reuse it.","title":"Graphics"},{"location":"graphics/#mesh","text":"The base object, which holds the information about the mesh, this being: vertices, indices and primitive type.","title":"Mesh"},{"location":"graphics/#constructors","text":"Mesh ( float [] vertices , bool isLine = false ) Mesh ( float [] vertices , uint [] indices , bool isLine = false ) The isLine parameter changes the primitive type of the Mesh into GL_LINES from GL_TRIANGLES .","title":"Constructors"},{"location":"graphics/#methods","text":"static void Translate(Vec3 position) Set state's position value. static void Rotate(Vec3 rotation) Set state's rotation value. static void RotateX(float rotation) Set state's rotation value. static void RotateY(float rotation) Set state's rotation value. static void RotateZ(float rotation) Set state's rotation value. static void PolygonMode(bool mode) Set true to fill polygons, and false not.","title":"Methods"},{"location":"graphics/#example","text":"As it is using an Uber shader at the moment, all the meshes, indistinctly of them being 2D or 3D, use 8 f32 to represent Vertex. The first 3 values are the position of the Vertex, followed by 2 values of Texture Coordinates, finished by 3 values of the Vertex's Normals. public class Line { public Mesh mesh { get ; private set ; } private void CreateLine ( float p0x , float p0y , float p1x , float p1y ) { float [] vertices = { p0x , p0y , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , p1x , p1y , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f }; mesh = new Mesh ( vertices , true ); } public Line ( float p0x , float p0y , float p1x , float p1y ) { CreateLine ( p0x , p0y , p1x , p1y ); } public Line ( Vec2 p0 , Vec2 p1 ) { CreateLine ( p0 . x , p0 . y , p1 . x , p1 . y ); } public void Draw () { mesh . Draw (); } } You can also, make Meshes with Indices for the Vertices: public class Rectangle { public Mesh mesh { get ; private set ; } public Rectangle ( float width , float height ) { float [] vertices = { ( width / 2.0f ), ( height / 2.0f ), 0.0f , 1.0f , 1.0f , 0.0f , 0.0f , 0.0f , ( width / 2.0f ), -( height / 2.0f ), 0.0f , 1.0f , 0.0f , 0.0f , 0.0f , 0.0f , -( width / 2.0f ), -( height / 2.0f ), 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , 0.0f , -( width / 2.0f ), ( height / 2.0f ), 0.0f , 0.0f , 1.0f , 0.0f , 0.0f , 0.0f }; uint [] indices = { 0 , 2 , 1 , 2 , 0 , 3 }; mesh = new Mesh ( vertices , indices ); } public void Draw () { mesh . Draw (); } } Please take into consideration that the renderer enables Culling in a Counter Clock Wise mode.","title":"Example"},{"location":"input/","text":"Input The Input is managed by the Window system, using GLFW to retrieve the system events. These events are then passed onto the Input system, which in turn manages the state of Pressed , Released , and their variants in JustPressed and JustReleased . Functions Using the Enums below, you can access their state by calling one of these functions: For Key , MouseButton , Pad : IsPressed() Checks if the state of the Key/Button is Pressed. IsJustPressed() Checks if the state of the Key/Button has changed to Pressed. Please note that this function must be called every frame for the State to properly flush. IsJustReleased() Checks if the state of the Key/Button has changed to Released. Please note that this function must be called every frame for the State to properly flush. For JoyStick : GetAxis() Returns a float with the Axis of the given JoyStick. Example void UpdateInput () { float speed = 2.5f * Time . deltaTime ; if ( Key . W . IsPressed ()) this . position -= front * speed ; if ( Key . S . IsPressed ()) this . position += front * speed ; if ( Key . A . IsPressed ()) this . position += front . Cross ( up ). Normalize () * speed ; if ( Key . D . IsPressed ()) this . position -= front . Cross ( up ). Normalize () * speed ; if ( Key . E . IsPressed ()) this . position += up * speed ; if ( Key . Q . IsPressed ()) this . position -= up * speed ; } Warning A possible mistake while using the Just variants is that they are not called in every frame. This is wrong: void Update () { if ( Key . LeftControl . IsPressed () && Key . Q . IsJustPressed ()) { // Something } } Since the second statement is not called on every frame, the state is not flushed properly, causing it to be always true whenever the Key Q has been pressed in the past, but not necessarily in that moment. Enums Key Unknown Space Apostrophe Comma Minus Period Slash N0 N1 N2 N3 N4 N5 N6 N7 N8 N9 Semicolon Equal A B C D E F G H I J K L M N O P Q R S T U V W X Y Z LeftBracket Backslash RightBracket GraveAccent World1 World2 Escape Enter Tab Backspace Insert Delete Right Left Down Up PageUp PageDown Home End CapsLock ScrollLock NumLock PrintScreen Pause F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 KP0 KP1 KP2 KP3 KP4 KP5 KP6 KP7 KP8 KP9 KPDecimal KPDivide KPMultiply KPSubtract KPAdd KPEnter KPEqual LeftShift LeftControl LeftAlt LeftSuper RightShift RightControl RightAlt RightSuper Menu MouseButton Left Right Middle Button3 Button4 Button5 Button6 Button7 Button8 Pad Pad0 Pad1 Pad2 Pad3 Pad4 Pad5 Pad6 Pad7 Pad8 Pad9 Pad10 Pad11 Pad12 Pad13 Pad14 Pad15 PadButton A B X Y LeftBumper RightBumper Back Start Guide LeftThumb RightThumb DPadUp DPadRight DPadDown DPadLeft JoyStick LeftX LeftY RightX RightY LeftBumper RightBumper","title":"Input"},{"location":"input/#input","text":"The Input is managed by the Window system, using GLFW to retrieve the system events. These events are then passed onto the Input system, which in turn manages the state of Pressed , Released , and their variants in JustPressed and JustReleased .","title":"Input"},{"location":"input/#functions","text":"Using the Enums below, you can access their state by calling one of these functions: For Key , MouseButton , Pad : IsPressed() Checks if the state of the Key/Button is Pressed. IsJustPressed() Checks if the state of the Key/Button has changed to Pressed. Please note that this function must be called every frame for the State to properly flush. IsJustReleased() Checks if the state of the Key/Button has changed to Released. Please note that this function must be called every frame for the State to properly flush. For JoyStick : GetAxis() Returns a float with the Axis of the given JoyStick.","title":"Functions"},{"location":"input/#example","text":"void UpdateInput () { float speed = 2.5f * Time . deltaTime ; if ( Key . W . IsPressed ()) this . position -= front * speed ; if ( Key . S . IsPressed ()) this . position += front * speed ; if ( Key . A . IsPressed ()) this . position += front . Cross ( up ). Normalize () * speed ; if ( Key . D . IsPressed ()) this . position -= front . Cross ( up ). Normalize () * speed ; if ( Key . E . IsPressed ()) this . position += up * speed ; if ( Key . Q . IsPressed ()) this . position -= up * speed ; } Warning A possible mistake while using the Just variants is that they are not called in every frame. This is wrong: void Update () { if ( Key . LeftControl . IsPressed () && Key . Q . IsJustPressed ()) { // Something } } Since the second statement is not called on every frame, the state is not flushed properly, causing it to be always true whenever the Key Q has been pressed in the past, but not necessarily in that moment.","title":"Example"},{"location":"input/#enums","text":"Key Unknown Space Apostrophe Comma Minus Period Slash N0 N1 N2 N3 N4 N5 N6 N7 N8 N9 Semicolon Equal A B C D E F G H I J K L M N O P Q R S T U V W X Y Z LeftBracket Backslash RightBracket GraveAccent World1 World2 Escape Enter Tab Backspace Insert Delete Right Left Down Up PageUp PageDown Home End CapsLock ScrollLock NumLock PrintScreen Pause F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24 F25 KP0 KP1 KP2 KP3 KP4 KP5 KP6 KP7 KP8 KP9 KPDecimal KPDivide KPMultiply KPSubtract KPAdd KPEnter KPEqual LeftShift LeftControl LeftAlt LeftSuper RightShift RightControl RightAlt RightSuper Menu MouseButton Left Right Middle Button3 Button4 Button5 Button6 Button7 Button8 Pad Pad0 Pad1 Pad2 Pad3 Pad4 Pad5 Pad6 Pad7 Pad8 Pad9 Pad10 Pad11 Pad12 Pad13 Pad14 Pad15 PadButton A B X Y LeftBumper RightBumper Back Start Guide LeftThumb RightThumb DPadUp DPadRight DPadDown DPadLeft JoyStick LeftX LeftY RightX RightY LeftBumper RightBumper","title":"Enums"},{"location":"light/","text":"Light Simple Light system that supports multiple Light Sources. Important In the Uber shader there is a Maximum of 256 Light Sources. Functions static void Enable () Enables the Light system by loading all given Light Sources into the current Shader. static void Disable () Disables the Light system by setting the Number of Lights to 0 and AmbientLight to 1. Light ( Vec3 position ) Create a Light with the given Position. void Destroy () Public pseudo destructor since you need to destroy the Light Source for it to cease having effect. Fields Vec3 Position Position of the Light Source, with custom Get and Set","title":"Light"},{"location":"light/#light","text":"Simple Light system that supports multiple Light Sources. Important In the Uber shader there is a Maximum of 256 Light Sources.","title":"Light"},{"location":"light/#functions","text":"static void Enable () Enables the Light system by loading all given Light Sources into the current Shader. static void Disable () Disables the Light system by setting the Number of Lights to 0 and AmbientLight to 1. Light ( Vec3 position ) Create a Light with the given Position. void Destroy () Public pseudo destructor since you need to destroy the Light Source for it to cease having effect.","title":"Functions"},{"location":"light/#fields","text":"Vec3 Position Position of the Light Source, with custom Get and Set","title":"Fields"},{"location":"math/","text":"Math Data structures that are useful when working with lineal algebra. Vec2 Two dimensional vector data structure. Fields x First component of the vector. (float) y Second component of the vector. (float) Constructors Vec2 ( float n ) Take a scalar and make all components this value. Vec2 ( float x , float y ) Take one scalar for each component. Vec2 ( Vec3 v ) Convert a Vec3 to Vec2 , losing the third component. Vec2 ( Vec4 v ) Convert a Vec4 to Vec2 , losing the third and fourth component. Methods [] Operator overload to access each respective component. +( Vec2 i , Vec2 j ) Operator overload. -( Vec2 i , Vec2 j ) Operator overload. *( Vec2 i , float k ) Operator overload, scalar affects each component. /( Vec2 i , float k ) Operator overload, scalar affects each component. +( Vec2 i , float k ) Operator overload, scalar affects each component. -( Vec2 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y ) Set the components of the Vec2 . MagnitudeSqrt () Calculates the magnitude of the Vec2 , squared. Magnitude () Calculates the magnitude of the Vec2 . Normalize () Normalize the Vec2 to a length of 1. Dot ( Vec2 other ) Calculates the dot product of two Vec2 . Angle ( Vec2 other ) Calculates the angle respective to other Vec2 . DistanceSqrt ( Vec2 other ) Calculate the distance between two Vec2 , squared. Distance ( Vec2 other ) Calculate the distance between two Vec2 . static down () Returns Vec2(0, -1) . static left () Returns Vec2(-1, 0) . static up () Returns Vec2(0, 1) . static right () Returns Vec2(1, 0) . static zero () Returns Vec2(0) . static one () Returns Vec2(1) . Example using System ; using VisualKey ; class App { Window window ; Vec2 pos = new Vec2 ( 0 ); void Start () { var x = new Vec2 ( 10 , 20 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23) var d = x . Dot ( new Vec2 ( 20 , 10 )); Console . WriteLine ( d ); // 490 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.4920573, y: 0.8705629) window = new Window (( uint ) size . x , ( uint ) size . y ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } } Vec3 Three dimensional vector data structure. Fields x First component of the vector. (float) y Second component of the vector. (float) z Third component of the vector. (float) Constructors Vec3 ( float n ) Take a scalar and make all components this value. Vec3 ( float x , float y , float z ) Take one scalar for each component. Vec3 ( Vec2 v , float z ) Convert a Vec2 to Vec3 , adding the third component. Vec3 ( Vec4 v ) Convert a Vec4 to Vec3 , losing the fourth component. Methods [] Operator overload to access each respective component. *( Vec3 v , Mat3 m ) Operator overload, multiply Vec3 to Mat3 . +( Vec3 i , Vec3 j ) Operator overload. -( Vec3 i , Vec3 j ) Operator overload. *( Vec3 i , float k ) Operator overload, scalar affects each component. /( Vec3 i , float k ) Operator overload, scalar affects each component. +( Vec3 i , float k ) Operator overload, scalar affects each component. -( Vec3 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y , float z ) Set the components of the Vec3 . MagnitudeSqrt () Calculates the magnitude of the Vec3 , squared. Magnitude () Calculates the magnitude of the Vec3 . Normalize () Normalize the Vec3 to a length of 1. Dot ( Vec3 other ) Calculates the dot product of two Vec3 . Angle ( Vec3 other ) Calculates the angle respective to other Vec3 . Cross ( Vec3 other ) Calculates the cross product respective to other Vec3 . DistanceSqrt ( Vec3 other ) Calculate the distance between two Vec3 , squared. Distance ( Vec3 other ) Calculate the distance between two Vec3 . RGB () Return a new Vec3 with same components divided by 255.0f . static back () Returns Vec3(0, 0, -1) . static down () Returns Vec3(0, -1, 0) . static left () Returns Vec3(-1, 0, 0) . static forward () Returns Vec3(0, 0, 1) . static up () Returns Vec3(0, 1, 0) . static right () Returns Vec3(1, 0, 0) . static zero () Returns Vec3(0) . static one () Returns Vec3(1) . Example using System ; using VisualKey ; class App { Window window ; Vec3 pos = new Vec3 ( 0 ); void Start () { var x = new Vec3 ( 10 , 20 , 30 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23, z: 33) var d = x . Dot ( new Vec3 ( 30 , 20 , 10 )); Console . WriteLine ( d ); // 1180 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.3075255, y: 0.5440835, z: 0.7806416) window = new Window ( 1280 , 720 ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } } Vec4 Four dimensional vector data structure. Fields x First component of the vector. (float) y Second component of the vector. (float) z Third component of the vector. (float) z Fourth component of the vector. (float) Constructors Vec4 ( float n ) Take a scalar and make all components this value. Vec4 ( float x , float y , float z , float w ) Take one scalar for each component. Vec4 ( Vec2 v , float z , float w ) Convert a Vec2 to Vec4 , adding the third and fourth component. Vec4 ( Vec3 v , float w ) Convert a Vec3 to Vec4 , adding the fourth component. Vec4 ( Quat q ) Convert a Quat to Vec4 . Methods [] Operator overload to access each respective component. +( Vec4 i , Vec4 j ) Operator overload. -( Vec4 i , Vec4 j ) Operator overload. *( Vec4 i , float k ) Operator overload, scalar affects each component. /( Vec4 i , float k ) Operator overload, scalar affects each component. +( Vec4 i , float k ) Operator overload, scalar affects each component. -( Vec4 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y , float z , float w ) Set the components of the Vec4 . MagnitudeSqrt () Calculates the magnitude of the Vec4 , squared. Magnitude () Calculates the magnitude of the Vec4 . Normalize () Normalize the Vec4 to a length of 1. Dot ( Vec4 other ) Calculates the dot product of two Vec4 . Angle ( Vec4 other ) Calculates the angle respective to other Vec4 . DistanceSqrt ( Vec4 other ) Calculate the distance between two Vec4 , squared. Distance ( Vec4 other ) Calculate the distance between two Vec4 . RGBA () Return a new Vec4 with same components divided by 255.0f , except the fourth which is divided by 100.0f . static zero () Returns Vec4(0) . static one () Returns Vec4(1) . Example using System ; using VisualKey ; class App { Window window ; Vec4 pos = new Vec4 ( 0 ); void Start () { var x = new Vec4 ( 10 , 20 , 30 , 40 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23, z: 33) var d = x . Dot ( new Vec4 ( 40 , 30 , 20 , 10 )); Console . WriteLine ( d ); // 2300 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.2155914, y: 0.3814309, z: 0.5472704, w: 0.71311) window = new Window ( 1280 , 720 ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } } Mat3 Three dimensional matrix data structure. Fields row0 First component of the matrix. (Vec3) row1 Second component of the matrix. (Vec3) row2 Third component of the matrix. (Vec3) Constructors Mat3 ( float n ) Take a scalar and make all components this value. Mat3 ( Vec3 row0 , Vec3 row1 , Vec3 row2 ) Take three Vec3 and make each row this value. Take one scalar per each component of the Mat3 : Mat3 ( float v00 , float v01 , float v02 , float v03 , float v04 , float v05 , float v06 , float v07 , float v08 ) Methods [] Operator overload to access each respective component. *( Mat3 m , float k ) Operator overload, scalar affects each component. /( Mat3 m , float k ) Operator overload, scalar affects each component. +( Mat3 m , float k ) Operator overload, scalar affects each component. -( Mat3 m , float k ) Operator overload, scalar affects each component. *( Mat3 m , Mat3 other ) Multiply two Mat3 . ToArray () Convert Mat3 to float[9] . static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) . Example using System ; using VisualKey ; class App { void Start () { var m = new Mat3 ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ); var o = m * Mat3 . identity (); Console . WriteLine ( o ); } } Mat4 Four dimensional matrix data structure. Fields row0 First component of the matrix. (Vec4) row1 Second component of the matrix. (Vec4) row2 Third component of the matrix. (Vec4) row3 Fourth component of the matrix. (Vec4) Constructors Mat4 ( float n ) Take a scalar and make all components this value. Mat4 ( Vec4 row0 , Vec4 row1 , Vec4 row2 , Vec4 row3 ) Take four Vec4 and make each row this value. Take one scalar per each component of the Mat4 : Mat4 ( float v00 , float v01 , float v02 , float v03 , float v04 , float v05 , float v06 , float v07 , float v08 , float v09 , float v10 , float v11 , float v12 , float v13 , float v14 , float v15 ) Methods [] Operator overload to access each respective component. *( Mat4 m , float k ) Operator overload, scalar affects each component. /( Mat4 m , float k ) Operator overload, scalar affects each component. +( Mat4 m , float k ) Operator overload, scalar affects each component. -( Mat4 m , float k ) Operator overload, scalar affects each component. *( Mat4 m , Mat4 other ) Multiply two Mat4 . ToArray () Convert Mat4 to float[16] . Scale ( Vec3 elements ) LookAt ( Vec3 eye , Vec3 at , Vec3 up ) Ortho ( float left , float right , float bottom , float top , float zNear , float zFar ) Perspective ( float fov , float aspect , float zNear , float zFar ) RotateX ( float angle ) RotateY ( float angle ) RotateZ ( float angle ) Translate ( Vec3 offset ) static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) . Example using System ; using VisualKey ; class App { void Start () { var m = new Mat4 ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ); var o = m * Mat4 . identity (); Console . WriteLine ( o ); } } Quat Quaternion data structure. Fields x First component of the quaternion. (float) y Second component of the quaternion. (float) z Third component of the quaternion. (float) w Fourth component of the quaternion. (float) Constructors Quat ( float n ) Take a scalar and make all components this value. Quat ( float x , float y , float z , float w ) Take a scalar per each component. Quat ( Vec4 v ) Take a Vec4 and convert it to Quat . Quat ( Vec3 axis , float angle ) Take a Vec3 and convert it to Quat by providing an angle. Quat ( Mat3 m ) Convert a Mat3 to Quat . Methods [] Operator overload to access each respective component. *( Quat q , float k ) Operator overload, scalar affects each component. /( Quat q , float k ) Operator overload, scalar affects each component. +( Quat q , float k ) Operator overload, scalar affects each component. -( Quat q , float k ) Operator overload, scalar affects each component. *( Quat q , Quat other ) Operator overload, multiply two Quat . *( Quat q , Vec3 v ) Operator overload, multiply Quat with a Vec3 . Set ( float x , float y , float z , float w ) Set each component value. Conjugate () Inverse () Rotate ( float angle , Vec3 v ) Roll () Pitch () Yaw () EulerAngles () Dot () Mat3 () Convert Quat to Mat3 . Mat4 () Mat4 ( Vec4 v ) Mat4 ( Vec3 v ) static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) . MathV Math utilities to work with float values. Radians ( float angle ) Convert an angle to radians. Clamp ( float v , float l , float r )","title":"Math"},{"location":"math/#math","text":"Data structures that are useful when working with lineal algebra.","title":"Math"},{"location":"math/#vec2","text":"Two dimensional vector data structure.","title":"Vec2"},{"location":"math/#fields","text":"x First component of the vector. (float) y Second component of the vector. (float)","title":"Fields"},{"location":"math/#constructors","text":"Vec2 ( float n ) Take a scalar and make all components this value. Vec2 ( float x , float y ) Take one scalar for each component. Vec2 ( Vec3 v ) Convert a Vec3 to Vec2 , losing the third component. Vec2 ( Vec4 v ) Convert a Vec4 to Vec2 , losing the third and fourth component.","title":"Constructors"},{"location":"math/#methods","text":"[] Operator overload to access each respective component. +( Vec2 i , Vec2 j ) Operator overload. -( Vec2 i , Vec2 j ) Operator overload. *( Vec2 i , float k ) Operator overload, scalar affects each component. /( Vec2 i , float k ) Operator overload, scalar affects each component. +( Vec2 i , float k ) Operator overload, scalar affects each component. -( Vec2 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y ) Set the components of the Vec2 . MagnitudeSqrt () Calculates the magnitude of the Vec2 , squared. Magnitude () Calculates the magnitude of the Vec2 . Normalize () Normalize the Vec2 to a length of 1. Dot ( Vec2 other ) Calculates the dot product of two Vec2 . Angle ( Vec2 other ) Calculates the angle respective to other Vec2 . DistanceSqrt ( Vec2 other ) Calculate the distance between two Vec2 , squared. Distance ( Vec2 other ) Calculate the distance between two Vec2 . static down () Returns Vec2(0, -1) . static left () Returns Vec2(-1, 0) . static up () Returns Vec2(0, 1) . static right () Returns Vec2(1, 0) . static zero () Returns Vec2(0) . static one () Returns Vec2(1) .","title":"Methods"},{"location":"math/#example","text":"using System ; using VisualKey ; class App { Window window ; Vec2 pos = new Vec2 ( 0 ); void Start () { var x = new Vec2 ( 10 , 20 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23) var d = x . Dot ( new Vec2 ( 20 , 10 )); Console . WriteLine ( d ); // 490 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.4920573, y: 0.8705629) window = new Window (( uint ) size . x , ( uint ) size . y ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } }","title":"Example"},{"location":"math/#vec3","text":"Three dimensional vector data structure.","title":"Vec3"},{"location":"math/#fields_1","text":"x First component of the vector. (float) y Second component of the vector. (float) z Third component of the vector. (float)","title":"Fields"},{"location":"math/#constructors_1","text":"Vec3 ( float n ) Take a scalar and make all components this value. Vec3 ( float x , float y , float z ) Take one scalar for each component. Vec3 ( Vec2 v , float z ) Convert a Vec2 to Vec3 , adding the third component. Vec3 ( Vec4 v ) Convert a Vec4 to Vec3 , losing the fourth component.","title":"Constructors"},{"location":"math/#methods_1","text":"[] Operator overload to access each respective component. *( Vec3 v , Mat3 m ) Operator overload, multiply Vec3 to Mat3 . +( Vec3 i , Vec3 j ) Operator overload. -( Vec3 i , Vec3 j ) Operator overload. *( Vec3 i , float k ) Operator overload, scalar affects each component. /( Vec3 i , float k ) Operator overload, scalar affects each component. +( Vec3 i , float k ) Operator overload, scalar affects each component. -( Vec3 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y , float z ) Set the components of the Vec3 . MagnitudeSqrt () Calculates the magnitude of the Vec3 , squared. Magnitude () Calculates the magnitude of the Vec3 . Normalize () Normalize the Vec3 to a length of 1. Dot ( Vec3 other ) Calculates the dot product of two Vec3 . Angle ( Vec3 other ) Calculates the angle respective to other Vec3 . Cross ( Vec3 other ) Calculates the cross product respective to other Vec3 . DistanceSqrt ( Vec3 other ) Calculate the distance between two Vec3 , squared. Distance ( Vec3 other ) Calculate the distance between two Vec3 . RGB () Return a new Vec3 with same components divided by 255.0f . static back () Returns Vec3(0, 0, -1) . static down () Returns Vec3(0, -1, 0) . static left () Returns Vec3(-1, 0, 0) . static forward () Returns Vec3(0, 0, 1) . static up () Returns Vec3(0, 1, 0) . static right () Returns Vec3(1, 0, 0) . static zero () Returns Vec3(0) . static one () Returns Vec3(1) .","title":"Methods"},{"location":"math/#example_1","text":"using System ; using VisualKey ; class App { Window window ; Vec3 pos = new Vec3 ( 0 ); void Start () { var x = new Vec3 ( 10 , 20 , 30 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23, z: 33) var d = x . Dot ( new Vec3 ( 30 , 20 , 10 )); Console . WriteLine ( d ); // 1180 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.3075255, y: 0.5440835, z: 0.7806416) window = new Window ( 1280 , 720 ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } }","title":"Example"},{"location":"math/#vec4","text":"Four dimensional vector data structure.","title":"Vec4"},{"location":"math/#fields_2","text":"x First component of the vector. (float) y Second component of the vector. (float) z Third component of the vector. (float) z Fourth component of the vector. (float)","title":"Fields"},{"location":"math/#constructors_2","text":"Vec4 ( float n ) Take a scalar and make all components this value. Vec4 ( float x , float y , float z , float w ) Take one scalar for each component. Vec4 ( Vec2 v , float z , float w ) Convert a Vec2 to Vec4 , adding the third and fourth component. Vec4 ( Vec3 v , float w ) Convert a Vec3 to Vec4 , adding the fourth component. Vec4 ( Quat q ) Convert a Quat to Vec4 .","title":"Constructors"},{"location":"math/#methods_2","text":"[] Operator overload to access each respective component. +( Vec4 i , Vec4 j ) Operator overload. -( Vec4 i , Vec4 j ) Operator overload. *( Vec4 i , float k ) Operator overload, scalar affects each component. /( Vec4 i , float k ) Operator overload, scalar affects each component. +( Vec4 i , float k ) Operator overload, scalar affects each component. -( Vec4 i , float k ) Operator overload, scalar affects each component. Set ( float x , float y , float z , float w ) Set the components of the Vec4 . MagnitudeSqrt () Calculates the magnitude of the Vec4 , squared. Magnitude () Calculates the magnitude of the Vec4 . Normalize () Normalize the Vec4 to a length of 1. Dot ( Vec4 other ) Calculates the dot product of two Vec4 . Angle ( Vec4 other ) Calculates the angle respective to other Vec4 . DistanceSqrt ( Vec4 other ) Calculate the distance between two Vec4 , squared. Distance ( Vec4 other ) Calculate the distance between two Vec4 . RGBA () Return a new Vec4 with same components divided by 255.0f , except the fourth which is divided by 100.0f . static zero () Returns Vec4(0) . static one () Returns Vec4(1) .","title":"Methods"},{"location":"math/#example_2","text":"using System ; using VisualKey ; class App { Window window ; Vec4 pos = new Vec4 ( 0 ); void Start () { var x = new Vec4 ( 10 , 20 , 30 , 40 ); x += 3 ; Console . WriteLine ( x ); // (x: 13, y: 23, z: 33) var d = x . Dot ( new Vec4 ( 40 , 30 , 20 , 10 )); Console . WriteLine ( d ); // 2300 var n = x . Normalize (); Console . WriteLine ( n ); // (x: 0.2155914, y: 0.3814309, z: 0.5472704, w: 0.71311) window = new Window ( 1280 , 720 ); } void Update () { if ( Key . A . IsPressed ()) pos . x += Time . deltaTime * 1 ; Console . WriteLine ( \"x: \" + pos . x ); // Same as pos[0] } }","title":"Example"},{"location":"math/#mat3","text":"Three dimensional matrix data structure.","title":"Mat3"},{"location":"math/#fields_3","text":"row0 First component of the matrix. (Vec3) row1 Second component of the matrix. (Vec3) row2 Third component of the matrix. (Vec3)","title":"Fields"},{"location":"math/#constructors_3","text":"Mat3 ( float n ) Take a scalar and make all components this value. Mat3 ( Vec3 row0 , Vec3 row1 , Vec3 row2 ) Take three Vec3 and make each row this value. Take one scalar per each component of the Mat3 : Mat3 ( float v00 , float v01 , float v02 , float v03 , float v04 , float v05 , float v06 , float v07 , float v08 )","title":"Constructors"},{"location":"math/#methods_3","text":"[] Operator overload to access each respective component. *( Mat3 m , float k ) Operator overload, scalar affects each component. /( Mat3 m , float k ) Operator overload, scalar affects each component. +( Mat3 m , float k ) Operator overload, scalar affects each component. -( Mat3 m , float k ) Operator overload, scalar affects each component. *( Mat3 m , Mat3 other ) Multiply two Mat3 . ToArray () Convert Mat3 to float[9] . static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) .","title":"Methods"},{"location":"math/#example_3","text":"using System ; using VisualKey ; class App { void Start () { var m = new Mat3 ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 ); var o = m * Mat3 . identity (); Console . WriteLine ( o ); } }","title":"Example"},{"location":"math/#mat4","text":"Four dimensional matrix data structure.","title":"Mat4"},{"location":"math/#fields_4","text":"row0 First component of the matrix. (Vec4) row1 Second component of the matrix. (Vec4) row2 Third component of the matrix. (Vec4) row3 Fourth component of the matrix. (Vec4)","title":"Fields"},{"location":"math/#constructors_4","text":"Mat4 ( float n ) Take a scalar and make all components this value. Mat4 ( Vec4 row0 , Vec4 row1 , Vec4 row2 , Vec4 row3 ) Take four Vec4 and make each row this value. Take one scalar per each component of the Mat4 : Mat4 ( float v00 , float v01 , float v02 , float v03 , float v04 , float v05 , float v06 , float v07 , float v08 , float v09 , float v10 , float v11 , float v12 , float v13 , float v14 , float v15 )","title":"Constructors"},{"location":"math/#methods_4","text":"[] Operator overload to access each respective component. *( Mat4 m , float k ) Operator overload, scalar affects each component. /( Mat4 m , float k ) Operator overload, scalar affects each component. +( Mat4 m , float k ) Operator overload, scalar affects each component. -( Mat4 m , float k ) Operator overload, scalar affects each component. *( Mat4 m , Mat4 other ) Multiply two Mat4 . ToArray () Convert Mat4 to float[16] . Scale ( Vec3 elements ) LookAt ( Vec3 eye , Vec3 at , Vec3 up ) Ortho ( float left , float right , float bottom , float top , float zNear , float zFar ) Perspective ( float fov , float aspect , float zNear , float zFar ) RotateX ( float angle ) RotateY ( float angle ) RotateZ ( float angle ) Translate ( Vec3 offset ) static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) .","title":"Methods"},{"location":"math/#example_4","text":"using System ; using VisualKey ; class App { void Start () { var m = new Mat4 ( 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 0 , 1 , 2 , 3 , 4 , 5 , 6 ); var o = m * Mat4 . identity (); Console . WriteLine ( o ); } }","title":"Example"},{"location":"math/#quat","text":"Quaternion data structure.","title":"Quat"},{"location":"math/#fields_5","text":"x First component of the quaternion. (float) y Second component of the quaternion. (float) z Third component of the quaternion. (float) w Fourth component of the quaternion. (float)","title":"Fields"},{"location":"math/#constructors_5","text":"Quat ( float n ) Take a scalar and make all components this value. Quat ( float x , float y , float z , float w ) Take a scalar per each component. Quat ( Vec4 v ) Take a Vec4 and convert it to Quat . Quat ( Vec3 axis , float angle ) Take a Vec3 and convert it to Quat by providing an angle. Quat ( Mat3 m ) Convert a Mat3 to Quat .","title":"Constructors"},{"location":"math/#methods_5","text":"[] Operator overload to access each respective component. *( Quat q , float k ) Operator overload, scalar affects each component. /( Quat q , float k ) Operator overload, scalar affects each component. +( Quat q , float k ) Operator overload, scalar affects each component. -( Quat q , float k ) Operator overload, scalar affects each component. *( Quat q , Quat other ) Operator overload, multiply two Quat . *( Quat q , Vec3 v ) Operator overload, multiply Quat with a Vec3 . Set ( float x , float y , float z , float w ) Set each component value. Conjugate () Inverse () Rotate ( float angle , Vec3 v ) Roll () Pitch () Yaw () EulerAngles () Dot () Mat3 () Convert Quat to Mat3 . Mat4 () Mat4 ( Vec4 v ) Mat4 ( Vec3 v ) static identity () Returns an identity Mat3 . static zero () Returns Mat3(0) . static one () Returns Mat3(1) .","title":"Methods"},{"location":"math/#mathv","text":"Math utilities to work with float values. Radians ( float angle ) Convert an angle to radians. Clamp ( float v , float l , float r )","title":"MathV"},{"location":"shader/","text":"Shader This class allows you to load Shaders from a path and to access/modify uniforms inside the given Shader. You can also access the Uber shader and modify its Uniform values. The shaders loaded from here use a specific format to be able to load both Vertex and Fragment shaders in one file. To access the different types of Shader stages supported (Vertex and Fragment atm), you can use macros: #vertex to change into the Vertex shader and #fragment to change into the Fragment shader. You can also use #ignore macro to write into no Shader stage in particular. You are able to include other shaders by using the macro #include follow by a path relative to the given shader. Example: #include colour.glsl . Functions static Shader GetUberShader () Returns a Shader class with a reference to the Uber shader. Please note that this particular Shader has the destructor disabled. Shader ( string path ) Constructor for the Shader class. It takes a string as an argument and returns built shader. void Draw () Draws the given Shader, by selecting its program as the one to use when drawing meshes. int GetLocation ( string name ) Returns a location to a Uniform with the same name as the one given. Returns a -1 and an Error Log when no Uniform is found with the given name. Please note that no Draw of the Shader is done before getting the location, and if a Variable is not used inside the GLSL shader it might be removed to optimize it. uint GetProgram () Returns the OpenGL ID of the Shader Program. void SetInt ( int location , int val ) void SetVec2 ( int location , Vec2 val ) void SetVec3 ( int location , Vec3 val ) void SetVec4 ( int location , Vec4 val ) void SetMat3 ( int location , Mat3 val ) void SetMat4 ( int location , Mat4 val )","title":"Shader"},{"location":"shader/#shader","text":"This class allows you to load Shaders from a path and to access/modify uniforms inside the given Shader. You can also access the Uber shader and modify its Uniform values. The shaders loaded from here use a specific format to be able to load both Vertex and Fragment shaders in one file. To access the different types of Shader stages supported (Vertex and Fragment atm), you can use macros: #vertex to change into the Vertex shader and #fragment to change into the Fragment shader. You can also use #ignore macro to write into no Shader stage in particular. You are able to include other shaders by using the macro #include follow by a path relative to the given shader. Example: #include colour.glsl .","title":"Shader"},{"location":"shader/#functions","text":"static Shader GetUberShader () Returns a Shader class with a reference to the Uber shader. Please note that this particular Shader has the destructor disabled. Shader ( string path ) Constructor for the Shader class. It takes a string as an argument and returns built shader. void Draw () Draws the given Shader, by selecting its program as the one to use when drawing meshes. int GetLocation ( string name ) Returns a location to a Uniform with the same name as the one given. Returns a -1 and an Error Log when no Uniform is found with the given name. Please note that no Draw of the Shader is done before getting the location, and if a Variable is not used inside the GLSL shader it might be removed to optimize it. uint GetProgram () Returns the OpenGL ID of the Shader Program. void SetInt ( int location , int val ) void SetVec2 ( int location , Vec2 val ) void SetVec3 ( int location , Vec3 val ) void SetVec4 ( int location , Vec4 val ) void SetMat3 ( int location , Mat3 val ) void SetMat4 ( int location , Mat4 val )","title":"Functions"},{"location":"text/","text":"Text Text rendering class. Due to its nature this Class doesn't make use of the Uber shader, but of a custom one. It uses FreeType to load Font textures and Glyph information. It makes use of the Mesh transform state, so translation and rotation using the Mesh and Stash system are okay. What it doesn't use is the Color and Texture system, that's why each Text contains its own Color. Functions Text ( string text , Color color ) Creates a Text with the given Text and Color. void Draw ( float scale ) Renders the Text with the stored Color and given Scale. Fields string text The text string to draw. Color color Color to apply while rendering the Text. Examples It is recommended that you draw the Text at the end of your update, since the Blend Alpha function can complain if not. Text text = new Text ( \"delta: \" , new Color ( 255 , 255 , 255 )); void Update () { text . text = \"delta: \" + Time . deltaTime ; text . Draw (); }","title":"Text"},{"location":"text/#text","text":"Text rendering class. Due to its nature this Class doesn't make use of the Uber shader, but of a custom one. It uses FreeType to load Font textures and Glyph information. It makes use of the Mesh transform state, so translation and rotation using the Mesh and Stash system are okay. What it doesn't use is the Color and Texture system, that's why each Text contains its own Color.","title":"Text"},{"location":"text/#functions","text":"Text ( string text , Color color ) Creates a Text with the given Text and Color. void Draw ( float scale ) Renders the Text with the stored Color and given Scale.","title":"Functions"},{"location":"text/#fields","text":"string text The text string to draw. Color color Color to apply while rendering the Text.","title":"Fields"},{"location":"text/#examples","text":"It is recommended that you draw the Text at the end of your update, since the Blend Alpha function can complain if not. Text text = new Text ( \"delta: \" , new Color ( 255 , 255 , 255 )); void Update () { text . text = \"delta: \" + Time . deltaTime ; text . Draw (); }","title":"Examples"},{"location":"texture/","text":"Texture Texture This class allows you to load images and set them for access in the given Shader. It uses stb_image to load the Images and transform them into the correct format, using 4 channels (RGBA). While creating the Texture_2D in OpenGL it uses these parameters: glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR_MIPMAP_LINEAR ); glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE ); Functions static void SetNone () Sets the Texture used to ID 0, which disables any Texture. Texture ( string path ) Creates a Texture with the given path. void Draw () Sets the Texture used to the ID of this Texture. Color Colour*. It is a practical wrapper of a Vec4 which gives functionality to quickly load the value to the Color uniform in the current Shader. Functions Color ( Vec4 color ) Gets a Vec4 and divides the XYZ/RGB values by 255.0f, and the Alpha value by 100.0f if the value is bigger than 1.0f. Color ( Vec3 color ) Gets a Vec4 and divides the XYZ/RGB values by 255.0f, the Alpha value is 1.0f. Color ( uint r , uint g , uint b , uint a = 100 ) Constructor that receives each value, RGB is divided by 255.0f and Alpha always by 100.0f. void Draw () Quickly loads the Value into the current Shader into the Uniform Color","title":"Texture"},{"location":"texture/#texture","text":"","title":"Texture"},{"location":"texture/#texture_1","text":"This class allows you to load images and set them for access in the given Shader. It uses stb_image to load the Images and transform them into the correct format, using 4 channels (RGBA). While creating the Texture_2D in OpenGL it uses these parameters: glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MIN_FILTER , GL_LINEAR_MIPMAP_LINEAR ); glTexParameterf ( GL_TEXTURE_2D , GL_TEXTURE_MAG_FILTER , GL_LINEAR ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_S , GL_CLAMP_TO_EDGE ); glTexParameteri ( GL_TEXTURE_2D , GL_TEXTURE_WRAP_T , GL_CLAMP_TO_EDGE );","title":"Texture"},{"location":"texture/#functions","text":"static void SetNone () Sets the Texture used to ID 0, which disables any Texture. Texture ( string path ) Creates a Texture with the given path. void Draw () Sets the Texture used to the ID of this Texture.","title":"Functions"},{"location":"texture/#color","text":"Colour*. It is a practical wrapper of a Vec4 which gives functionality to quickly load the value to the Color uniform in the current Shader.","title":"Color"},{"location":"texture/#functions_1","text":"Color ( Vec4 color ) Gets a Vec4 and divides the XYZ/RGB values by 255.0f, and the Alpha value by 100.0f if the value is bigger than 1.0f. Color ( Vec3 color ) Gets a Vec4 and divides the XYZ/RGB values by 255.0f, the Alpha value is 1.0f. Color ( uint r , uint g , uint b , uint a = 100 ) Constructor that receives each value, RGB is divided by 255.0f and Alpha always by 100.0f. void Draw () Quickly loads the Value into the current Shader into the Uniform Color","title":"Functions"},{"location":"time/","text":"Time This allows to access both the Total time that the program has been running for and the delta time of the last frame. Functions static float deltaTime () Returns the delta time. static double time () Returns the total time the program has been running for.","title":"Time"},{"location":"time/#time","text":"This allows to access both the Total time that the program has been running for and the delta time of the last frame.","title":"Time"},{"location":"time/#functions","text":"static float deltaTime () Returns the delta time. static double time () Returns the total time the program has been running for.","title":"Functions"},{"location":"window/","text":"Window The window system is special, since it uses a hidden window to coordinate a shared OpenGL Context and coordinate system events, this window will be called default_window. Each window can be said to be tied to the default_window, this being the case since if all the windows have been closed the default_window will enter exit mode. The window to be made current context at the start of each Update is the first one to be created that is still active. You can force the current context by calling MakeCurrent . A window can still exist in the C# Script, but it may have become inactive in the C++ backend, this can occur due to System events, or simply because the user has called the Close function. Since the OpenGL Context is shared between all the windows, any resource created can be used in any window. The only warning to be given is that if you make use of more than one window, you must keep track of active windows and check if a window is active before drawing. Info When changing Projection type (Perspective <-> Ortho) call MakeCurrent , since this is the step in which the Projection Matrix is calculated and loaded into the Shader. Functions static void SetPerspective ( float fov ) Sets window projection mode to Perspective with the given FOV in Radians. static void SetOrtho () Sets window projection mode to Orthogonal. Window ( uint width , uint height , string title = \"VisualKey\" ) Creates a window with the given width, height and title. bool IsOrtho () bool IsPerspective () void Background ( uint r , uint g , uint b ) Sets Background color to the given values divided by 255. void Background ( Vec3 color ) Sets Background color to the given Vec3 divided by 255. void Background ( Color color ) Sets Background color to the given Color. void HideCursor () Hides window cursor and locks it. void ShowCursor () Shows window cursor and unlocks it. bool Fullscreen () Makes the window fullscreen and returns its fullscreen state. void MakeCurrent () Recalculates Projection Matrix and Makes the window the current context. void Close () Closes the window and makes it inactive. bool IsValid () Returns if the window is still active in the C++ backend. Fields size Returns the current Window size, it uses custom Get and Set to resize when changed. Example using System ; using VisualKey ; class App { Window window = new Window ( 1280 , 720 ); Rectangle rectangle = new Rectangle ( 100 , 100 ); void Start () { Console . WriteLine ( \"Starting...\" ); } void Update () { window . Background ( 33 , 33 , 33 ); rectangle . Draw (); } void Stop () { Console . WriteLine ( \"Stopping...\" ); } }","title":"Window"},{"location":"window/#window","text":"The window system is special, since it uses a hidden window to coordinate a shared OpenGL Context and coordinate system events, this window will be called default_window. Each window can be said to be tied to the default_window, this being the case since if all the windows have been closed the default_window will enter exit mode. The window to be made current context at the start of each Update is the first one to be created that is still active. You can force the current context by calling MakeCurrent . A window can still exist in the C# Script, but it may have become inactive in the C++ backend, this can occur due to System events, or simply because the user has called the Close function. Since the OpenGL Context is shared between all the windows, any resource created can be used in any window. The only warning to be given is that if you make use of more than one window, you must keep track of active windows and check if a window is active before drawing. Info When changing Projection type (Perspective <-> Ortho) call MakeCurrent , since this is the step in which the Projection Matrix is calculated and loaded into the Shader.","title":"Window"},{"location":"window/#functions","text":"static void SetPerspective ( float fov ) Sets window projection mode to Perspective with the given FOV in Radians. static void SetOrtho () Sets window projection mode to Orthogonal. Window ( uint width , uint height , string title = \"VisualKey\" ) Creates a window with the given width, height and title. bool IsOrtho () bool IsPerspective () void Background ( uint r , uint g , uint b ) Sets Background color to the given values divided by 255. void Background ( Vec3 color ) Sets Background color to the given Vec3 divided by 255. void Background ( Color color ) Sets Background color to the given Color. void HideCursor () Hides window cursor and locks it. void ShowCursor () Shows window cursor and unlocks it. bool Fullscreen () Makes the window fullscreen and returns its fullscreen state. void MakeCurrent () Recalculates Projection Matrix and Makes the window the current context. void Close () Closes the window and makes it inactive. bool IsValid () Returns if the window is still active in the C++ backend.","title":"Functions"},{"location":"window/#fields","text":"size Returns the current Window size, it uses custom Get and Set to resize when changed.","title":"Fields"},{"location":"window/#example","text":"using System ; using VisualKey ; class App { Window window = new Window ( 1280 , 720 ); Rectangle rectangle = new Rectangle ( 100 , 100 ); void Start () { Console . WriteLine ( \"Starting...\" ); } void Update () { window . Background ( 33 , 33 , 33 ); rectangle . Draw (); } void Stop () { Console . WriteLine ( \"Stopping...\" ); } }","title":"Example"}]}